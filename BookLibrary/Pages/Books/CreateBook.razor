@using BookLibrary.Data.Models;
@using BookLibrary.Db.Interfaces;
@using BookLibrary.Components;
@using BookLibrary.Core.Services;

@page "/Books/Create"

@inject IBookRepository repository
@inject IAuthorRepository authorRepository
@inject NavigationManager nagivation
@inject IFileService fileService
@inject IMatToaster toaster

<MatH3>Create Book</MatH3>

<MatPaper Elevation="5" Class="padding-16">
    <EditForm Model="model" OnValidSubmit="Success">
        <DataAnnotationsValidator />
        <p>
            <MatTextField Label="Title" @bind-Value="model.Title" FullWidth="true" />
        </p>
        <p>
            <MatTextField Label="Image URL" @bind-Value="model.ImageUrl" FullWidth="true" />
        </p>
        <p>
            <MultiAutocomplete TItem="AuthorModel" Items="authors" @bind-Value="model.Authors" Label="Authors" FullWidth="true" />
            <ValidationMessage For="@(() => model.Authors)" />
        </p>
        <p>
            <MatFileUpload OnChange="@MultipleFilesReady" AllowMultiple="true" Label="Drop files here or Browse"></MatFileUpload>
            <MatChipSet>
                @foreach (var file in model.Files)
                {
                    <MatChip class="mt-1" Label=@file.FileName TrailingIcon="clear" TrailingIconClick="@(_ => RemoveFile(file))"></MatChip>
                }
            </MatChipSet>
        </p>

        <MatButton Type="submit" Raised="true">Create</MatButton>
    </EditForm>
</MatPaper>

@code {
    BookModel model = new BookModel();
    List<AuthorModel> authors = new List<AuthorModel>();

    protected override async Task OnInitializedAsync()
    {
        var authorEntities = await authorRepository.ListAllAsync();
        authors.AddRange(authorEntities.Select(i => new AuthorModel(i)));
    }

    private async Task Success(EditContext editContext)
    {
        if (editContext.Validate())
        {
            var author = new Book
            {
                Title = model.Title,
                ImageUrl = model.ImageUrl,
                Authors = model.Authors.Select(i => i.Entity).ToList()
            };
            await repository.AddAsync(author);

            nagivation.NavigateTo("/Books/List");
        }
    }

    private async Task MultipleFilesReady(IMatFileUploadEntry[] files)
    {
        foreach (var file in files)
        {
            if (file.Size > fileService.MaxFileSize || !fileService.CanSave(file.Name, file.Type))
            {
                toaster.Add($"File {file.Name} cannot be loaded", MatToastType.Danger);
                continue;
            }

            var (stream, path) = fileService.GetTemporaryFileStream();
            using (stream)
            {
                await file.WriteToStreamAsync(stream);
                model.Files.Add(new FileModel
                {
                    FileName = file.Name,
                    FileType = file.Type,
                    TemporaryFilePath = path
                });
            }
        }
    }

    private void RemoveFile(FileModel fileModel)
    {
        model.Files.Remove(fileModel);
    }
}
