@*@using BookLibrary.Data.Models;
@using BookLibrary.Db.Interfaces;
@using BookLibrary.Components;
@using BookLibrary.Core.Services;
@using BookLibrary.Core.Specifications; 

@page "/Books/Add"

@inject IBookRepository repository
@inject IAuthorRepository authorRepository
@inject IBinaryFileRepository binaryFileRepository

@inject NavigationManager nagivation
@inject IFileService fileService
@inject ITemporaryFileService tempFileService
@inject IMatToaster toaster

<EntityForm Title="Add book">
    <EditForm Model="model" OnValidSubmit="Success">
        <DataAnnotationsValidator />
        <p>
            <MatTextField Label="Title" @bind-Value="model.Title" FullWidth="true" />
        </p>
        <p>
            <MatTextField Label="Description" @bind-Value="model.Description" FullWidth="true" />
        </p>
        <p>
            <MatAutocompleteList Items="@bookGroups" @bind-Value="@model.Parent" Label="Group" FullWidth="true" ShowClearButton="true" CustomStringSelector="@(i => i.Title)" />
        </p>
        <p>
            <MatTextField Label="Image URL" @bind-Value="model.ImageUrl" FullWidth="true" />
        </p>
        @if (model.Parent == null)
        {
            <p>
                <MultiAutocomplete TItem="AuthorModel" Items="authors" @bind-Value="model.Authors" Label="Authors" FullWidth="true" />
                <ValidationMessage For="@(() => model.Authors)" />
            </p>
        }
        <p>
            <MatFileUpload OnChange="@MultipleFilesReady" AllowMultiple="true" Label="Drop files here or Browse"></MatFileUpload>
            <MatChipSet>
                @foreach (var file in model.Files)
                {
                    <MatChip class="mt-1" Label=@file.FileName TrailingIcon="clear" TrailingIconClick="@(_ => RemoveFile(file))"></MatChip>
                }
            </MatChipSet>
        </p>

        <MatButton Type="submit" Raised="true">Create</MatButton>
    </EditForm>
</EntityForm>

@code {
    BookModel model = new BookModel();
    List<AuthorModel> authors = new List<AuthorModel>();
    List<BookModel> bookGroups = new List<BookModel>();

    protected override async Task OnInitializedAsync()
    {
        var authorEntities = await authorRepository.ListAllAsync();
        authors.AddRange(authorEntities.Select(i => new AuthorModel(i)));

        var groups = await repository.ListAsync(new BookGroupsSpecification());
        bookGroups.AddRange(groups.Select(i => new BookModel(i)));
    }

    private async Task Success(EditContext editContext)
    {
        if (editContext.Validate())
        {
            var files = new List<BinaryFile>();
            foreach (var file in model.Files)
            {
                var path = fileService.SaveFile(file.TemporaryFilePath, file.FileName);
                var entity = new BinaryFile
                {
                    FileName = file.FileName,
                    FilePath = path,
                    FileType = file.FileType
                };
                await binaryFileRepository.AddAsync(entity);
                files.Add(entity);
            }

            var book = new Book
            {
                Title = model.Title,
                ImageUrl = model.ImageUrl,
                Description = model.Description,
                Authors = model.Authors.Select(i => i.Entity).ToList(),
                IsGroup = model.IsGroup,
                Parent = model.Parent?.Entity,
                Files = files
            };
            await repository.AddAsync(book);

            nagivation.NavigateTo("/Books/List");
        }
    }

    private async Task MultipleFilesReady(IMatFileUploadEntry[] files)
    {
        foreach (var file in files)
        {
            if (file.Size > fileService.MaxFileSize || !fileService.CanSave(file.Name, file.Type))
            {
                toaster.Add($"File {file.Name} cannot be loaded", MatToastType.Danger);
                continue;
            }

            var path = await tempFileService.SaveFile(file.WriteToStreamAsync);
            model.Files.Add(new FileModel
            {
                FileName = file.Name,
                FileType = file.Type,
                TemporaryFilePath = path
            });
        }
    }

    private void RemoveFile(FileModel fileModel)
    {
        model.Files.Remove(fileModel);
    }
}*@
